# Midterm Exam Essay Responses

## Question 1 Essay

# Part A: 
According to Riel's heuristics, a well-designed class should have a high cohesion. Meaning:
1. All methods and attributes within the class should be working together to provied a single and well-defined responsibility.
2. Each method should be using some part of the class attributes.
3. The class should represent a single logical concept or entity within the system.

High cohesion is preferable because it:
- Simplifies maintenance and debugging
- Reduces complexity
- Makes the class more reusable and flexible
- Follows the Single Responsibility Principle in OO design

# Part B:
The StudentPortalHelper class demonstrates low cohesion for the following resonings:
1. Multiple Unrelated responsibilities
- GPA calculation (academic logic)
- File I/O (data persistence)
- Email formatting (communication)
- UI formatting (presentation)
- Payment processing (financial)
- Security (password validation)
- Caching (infrastructure)

2. Violation of Riel's heuristics
- The class acts as a "god class" containing multiple functionalities that are Unrelated
- Methods don't share common attributes or state 
- Most methods are static, suggesting utility behavior instead of a meaningful object-oriented design

# Proposed Refactoring Approach 
The class should be split into several cohesive classes, each with a single responsibility:

```
org.howard.edu.lsp.studentPortal
├── academic/
│   └── GPACalculator.java
├── io/
│   └── RosterExporter.java
├── communication/
│   └── EmailFormatter.java
├── ui/
│   └── DateFormatter.java
├── payment/
│   └── TuitionProcessor.java
├── security/
│   └── PasswordValidator.java
└── infrastructure/
    └── CacheService.java
```

Each new class would focus on one specific aspect of the system, improving:
- Better Maintainability and Readibility
- Improved Testability
- Reusability
- Code organization

This refactoring aligns with both Riel's heuristics and the Single Responsibility Principle of SOLID design principles.

## Question 3 Essay

#Part A:

The current structure does not adequately support dynamic trim level changes for multiple reasons:
1. Inheritence Limitation
- The Base, Sports, and Luxury classes inherit from Car.
- In Java, inheritence is fixed at compile time.
- This means a car object's type cannot be changed at runtime.
- Example: A Base car cannot be converted into a Sports car without creating a new object.

2. Object Identity problem
- Changing the trim level would require creating a new object.
- This breaks object continuity because all existing refrences would still point to the old car instance.
- Any existing state would still be lost during transformation.

# Part B

The solution is to use the Strategy Pattern with composition instead of inheritence:

```java
// Trim level becomes an interface
interface TrimLevel {
    String getTrimLevel();
}

// Concrete implementations of trim levels
class BaseTrim implements TrimLevel {
    public String getTrimLevel() { return "Base"; }
}

class SportsTrim implements TrimLevel {
    public String getTrimLevel() { return "Sports"; }
}

class LuxuryTrim implements TrimLevel {
    public String getTrimLevel() { return "Luxury"; }
}

// Modified Car class using composition
class Car {
    private TrimLevel trimLevel;
    private Engine engine;
    
    // Method to change trim level dynamically
    public void setTrimLevel(TrimLevel newTrim) {
        this.trimLevel = newTrim;
    }
    
    public String getTrimLevel() {
        return trimLevel.getTrimLevel();
    }
}
```

Benefits of this approach:
Dynamic Trim Changes: Trim level can be updated at runtime without creating a new object.
Object Continuity: The same Car instance maintains its identity throughout its lifecycle.
State Preservation: Existing properties such as the engine remain unchanged.
Flexible Design: New trim levels can be added without modifying the Car class.
Clean and Maintainable: Follows the Open/Closed Principle of SOLID design.

This solution allows statements like:
```java
Car myCar = new Car(new BaseTrim(), new ElectricEngine());
// Later in the manufacturing process...
myCar.setTrimLevel(new SportsTrim());  // Dynamically change trim
```

## Question 4 Rationale

Why Device is abstract:
Device is defined as an abstract class because it provides common fields and methods for all devices (like id, location, heartbeat, and connection status) but leaves getStatus() abstract. This allows each concrete device to implement its own status format while sharing the common behavior.

Role of Networked and BatteryPowered interfaces:
The Networked and BatteryPowered interfaces allow concrete devices to adopt specific behaviors independently of the base class. For example, DoorLock and Camera are battery-powered, while Thermostat is not, but all can connect to a network.

Multiple inheritance in Java?:
This design is not true multiple inheritance because Java does not allow extending more than one class. Instead, it uses interfaces to provide additional behavior, which is Java's way to achieve multiple inheritance-like flexibility safely.

## Question 5
Throughout this course, I've mostly used ChatGPT as a learning aid. This AI tool has been helping me work through tricky concepts and suggesting various ways to approach problems. For instance, When tackling OO designs, AI helped me to visualize different class structures and weigh the trade-offs between inheritance and composition.
At the Same time, I've noticed it's limitations. Sometimes the suggestions are overly complex and don't meet the assignment requirements. This has taught me to critically evaluate AI advice instead of blindly accepting it and pressing submit. 

Looking Ahead, I see AI become an integral part of my programming workflow but in a balanced way. I don;t plan on relying it to code for me but rather using it to explore design patterns, suggest optimizations, and clarify concepts that I may not be able to grasp. In professional settings, I expect AI tools will help me work more efficiently, but still will be of importance
to maintain a foundational understanding. The key is to use AI when enhancing my skills but not to replace my personal critical thinking and problem solving skills.